## HTML CSS

### 语义标签

代码可读性，有利于架构良好的 HTML 结构，便于团队开发和维护

有利于 SEO 搜索引擎优化，有助于爬虫抓取更多有效信息，确定上下文

可访问性 （网络无障碍），设备解析页面结构，以帮助用户按照页面制作者的意图来引导用户，获取关心的内容

结构：

- `<header>` ：页眉
- `<main>` ：主要内容
- `<footer>` ：页脚
- `<section>` ：文档中一个通用独立章节，它没有更具体的语义元素来表示

内容：

- `<article>` ：完全独立的内容区域
- `<nav>` ：导航
- `<aside>` ：侧边栏或标注栏，可以被独立的拆分而不会使整体受影响
- `<address>` ：联系方式
- `<blockquote>` ：块级引用元素
- `<cite>`
- `<code>`
- `<data>`
- `<del>`
- `<figure>`
- `<ins>`
- `<time>`
- `<var>`

### CSS 选择器优先级

1. !important——无敌
2. 行内样式（style）1 0 0 0
3. ID 选择器（`#example`） 0 1 0 0
4. 类选择器（`.example`） / 属性选择器（`[type="radio"]`） / 伪类选择器（`:hover`） 0 0 1 0
5. 类型选择器（`h1`） / 伪元素选择器（`::before`） 0 0 0 1
6. 继承——最弱
7. 浏览器默认——直接无视

> 通配选择符（*）关系选择符（+, >, ~, " ", ||）和 否定伪类（:not()）对优先级没有影响。（但是，在 :not() 内部声明的选择器会影响优先级）。

多条规则比权重，优先级相同看最后

### 伪类和伪元素

> 伪类是选择器的一种，它用于选择处于特定状态的元素

- :hover
- :active
- :checked
- :visited
- :empty
- :is
- :not
- :where
- :has
- ……

> 伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。

- ::after 已选中元素的最后一个子元素，配合 `content` 属性添加装饰内容

- ::before

- ::first-line

- ::first-letter

- ::file-selector-button `type="file"` 的 `<input>` 的按钮

- ::selection 文档中被用户高亮的部分（比如鼠标选中）

- ……

  

### 水平垂直居中

1. absolute 绝对定位后，利用利用 margin、calc、transform 找到正确位置

   - margin （定宽高）

     - ```css
       .box{
         position: absolute;;
         top: 50%;
         left: 50%;
         margin-left: -50px; // 元素宽度的一半
         margin-top: -50px; // 元素高度的一半
       }
       ```

     - ```css
       .box {
         position: absolute;;
         top: 0;
         left: 0;
         right: 0;
         bottom: 0;
         margin: auto;
       }
       ```

   -  calc（定宽高）

     ```css
     .box {
       position: absolute;;
       top: calc(50% - 50px);
       left: calc(50% - 50px);
     }
     ```

   - transform（不定宽高）

     ```css
     .box {
       position: absolute;
       top: 50%;
       left: 50%;
       translate: -50% -50%;
     }
     ```

2. flex 布局

   ```css
   .wrapper {
     display: flex;
     justify-content: cneter;
     align-items: cneter;
   }
   ```

3. grid 布局

   ```css
   .wrapper {
   	display: grid;
   }
   .box {
   	align-self: center;
     justify-self: center;
   }
   ```

4. 转为 inline-block 行内块元素后利用 text-align、vertical-align 进行居中

   条件：子元素中有内联元素（文字等）。

   ```css
   .wrapper {
   	line-height: 300px;
     text-align: cneter
   }
   .box {
   	display: inline-block;
     vertical-align: cneter;
   	line-height: initial;
   }
   ```

5. 利用 css-table 把普通元素变为 table 元素的效果，实现居中

   ```css
   .wrapper {
     display: table-cell;
     text-align: center;
     vertical-align: middle;
   }
   .box {
     display: inline-block;
   }
   ```

6. 其他
   - writing-mode
   - table

### BFC

> Block Formatting Context，块级格式化上下文

BFC是一个**块级元素**，是一个隔离的**独立容器**（空间里的子元素不会影响到外面的布局）。它将：

- 包含内部浮动
- 排除外部浮动
- 阻止[外边距重叠 - CSS：层叠样式表 | ](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing)

触发条件：

- overflow 除 visible 和 clip 以外（hidden、auto、scroll）
- display: inline-block、table-cells、table-caption、flow-root
- 弹性元素：flex、inline-flex 的直接子元素
- 网格元素：grid、inline-grid 的直接子元素
- position: absolute、fixed
- contain

用途：

- 清除浮动 （父容器高度塌陷）

  给父容器触发 BFC

- margin 外边距重叠（标准文档流中**完全接触**的**竖直方向**的大 margin 会覆盖掉较小 margin）

  待研究

- 两栏布局（第二个元素被第一个 float 元素覆盖）

  给第二个元素设置 BFC

### flex

### grid

### 画三角形

- border 边框

  ```css
  .triangle {
    width: 0;
    height: 0;
    border-left: 100px solid red;
    border-right: 100px solid blue;
    border-bottom: 100px solid yellow;
    border-bottom: 100px solid green;
  }
  ```

- linear-gradient 渐变

  设置背景

  ```css
  .triangle {
    width: 160px;
    height: 200px;
    outline: 2px solid skyblue;
    background-repeat: no-repeat;
    background-image: linear-gradient(32deg, orangered 50%, rgba(255, 255, 255, 0) 50%), linear-gradient(148deg, orangered 50%, rgba(255, 255, 255, 0) 50%);
    background-size: 100% 50%;
    background-position: top left, bottom left;
  }
  ```

- clip-path 裁剪

  ```css
  .triangle {
    width: 100px;
    height: 100px;
    background-color: blue;
    clip-path: polygon(0 0, 0% 100%,100% 50%);
  }
  ```

  polygon 函数绘制多边形，轨迹点坐标

### 画扇形

使用边框圆角（左上，右上，右下，左下）

```css
.shape {
  width: 100px;
  height: 100px;
  background-color: red;
  border-radius: 100% 0 0 0;
}
```

### 画椭圆

边框圆角给定两个半径（水平、垂直）

```css
.shape {
  width: 200px;
  height: 100px;
  background-color: blue;
  border-radius: 50% 50%;
}
```



## 浏览器

### 从出入 URL 到页面展示发生了什么

1. 用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL 
2.  用户输入完内容，按下回车键，浏览器导航栏显示loading状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得 
3.  浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将URL请求发送给网络进程 GET /index.html HTTP1.1 
4. 网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程 
5. 网络进程请求DNS返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，http默认80，https默认443。如果是https请求，还需要建立TLS连接。 
6. Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立TCP连接。 
7. TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输 
8. 网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层 
9. 底层通过物理网络传输给目的服务器主机 
10. 目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层 
11. 目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层 
12. 应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段： Cache-Control:Max-age=2000 响应数据又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程 
13.  数据传输完成，TCP四次挥手断开连接。如果，浏览器或者服务器在HTTP头部加上如下信息，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提示资源加载速度 Connection:Keep-Alive  
14. 网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是text/html类型，就通知浏览器进程获取到文档准备渲染 
15. 浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程 
16. 浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程 
17. 浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页 18. 渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来





## JS

### 数据类型

- 基本数据类型（存储于栈中，空间小、大小固定、使用频繁）

  - Number [表示范围](https://cloud.tencent.com/developer/article/1488194#:~:text=JavaScript%20%E7%9A%84%20Number%20%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%2053%20%E4%BD%8D%E8%A1%A8%E7%A4%BA%E5%B0%8F%E6%95%B0%E4%BD%8D%EF%BC%8C10%20%E4%BD%8D%E8%A1%A8%E7%A4%BA%E6%8C%87%E6%95%B0%E4%BD%8D%EF%BC%8C1%20%E4%BD%8D%E8%A1%A8%E7%A4%BA%E7%AC%A6%E5%8F%B7%E4%BD%8D%E3%80%82,%E3%80%82%20%E5%9B%A0%E6%AD%A4%E5%AF%B9%E4%BA%8E%20Number%20%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%98%AF%202%5E1024%20%EF%BC%8C%20%E4%B9%9F%E5%B0%B1%E6%98%AF%201.7976931348623157e%2B308.)

  - Boolean

  - String
  - Undefined
  - Null
  - Symbol（ES6 新增）
  - BigInt（ES6 新增）

- 引用数据类型（实体存储于堆中，空间大、大小不固定，栈存储该实体起始地址）
  - Object

### 数据类型检测方式

1. typeof

   数组（或 字典等）、对象、null 都会被判断为 object

2. instanceof

   判断在其原型链中能否找到该类型的原型。

3. constructor

   根据构造函数判断类型。

   基本数据类型转化为对象判断：

   ```javascript
   console.log((2).constructor === Number); // true
   ```

4. Object.prototype.toString.call()

   使用 Object 对象的原型方法 toString 来判断（function、array 类型都重写了 toString 方法）

### 类型其他杂题

- 0.1 + 0.2 != 0.3
- typeof NaN 结果：number
- 其他值到字符串的转换规则
- 其他值到数字值的转换规则
- 其他值到布尔类型值的转换规则
- || 和 && 操作符
- `Object.is()`  与 ` ===`、`==` 的区别
- 包装类型：操作基本类型值时会在后台隐士转换为类型对象
- 隐式类型转换

### 原型链

![img](https://images2018.cnblogs.com/blog/1265396/201711/1265396-20171127082821065-1506469155.png)

原型链上的所有原型都是对象，所有的对象都是由 Obect 构造的，原型链终点 `Object.prototype.__proto__` 为 `null`。

`hasOwnProperty()` ：判断属性是否属于原型链的属性。

`getPrototypeOf()`：获取对象的原型。

### 执行上下文

一段 JavaScript 代码实际上是运行在执行上下文中，或者说**容器环境**，或者说是一个**内存空间**，是一个**抽象的概念**，每执行一次产生一个新的执行上下文环境。

- 全局执行上下文：运行代码主体的执行上下文，为存在于函数外的任何代码创建
- 函数执行上下文：每个函数在执行的时候会创建自己的上下文
- Eval 函数执行上下文：使用 `eval()` 函数创建的

#### 创建步骤

1. 确定 `this`

2. 创建**词法环境**

   包含标识符（变量 / 函数名称）变量（对象或原始值的引用）映射的结构。

   （如：`var name = 1` 标识符：`name`，引用 `1`）

   包含两部分：

   - 环境记录器：存储当前环境中的变量和函数声明的实际位置。

     （全局环境中拥有自建的 Object、Array 等、全局对象）

     （函数环境中有 arguments 对象和 length）

   - 外部环境的引用：可以访问的外部环境

     （全局环境中为 null）

3. 创建**变量环境**

   在 ES6 中明显的区别时前者用来存储函数声明和变量（let / const）的绑定，后者用来存储 var 变量的绑定。

#### 执行栈

```javascript
var say = function(){
  hello();
}
var hello = function(){
  console.log("Hello,world!");
}
say();
```

![未标题-2.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec15c6656d844805a498a7070d57803f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

### 深浅拷贝

#### 浅拷贝

> 对象的**浅拷贝**是其属性与拷贝源对象的属性共享**相同引用**（指向相同的底层值）的副本。假如对象是一个对象的引用，它仅仅会赋值其引用值。

浅拷贝：

- `Object.assign(target, source)`

  只会拷贝源对象**可枚举**（`Object.propertyIsEnumerable()`）和**自身的**（`Object.hasOwnProperty()`）属性（String 和 Symbol）到目标对象

  - 会调用源对象的 getters 和目标对象的 setters。

  - 原型链上的属性和不可枚举属性不能被复制。
  - 基本类型会被包装为对象（只有 string 类型会被包装成可枚举对象。

- 扩展操作符（ ... ）

  不复制继承的属性或类的属性，但是会复制 symbols 属性。

深拷贝：

- `JSON.parse(JSON.stringfy(obj))`



### let const var

创建执行上下文时未赋值，在执行上下文中运行/解释函数代码，并在代码逐行执行时分配变量值。

### 作用域、作用域链

代码的执行环境

>  [与执行上下文区别和联系](https://segmentfault.com/a/1190000011843356)：作用域是一个静态观念，相当于一个地盘，不包含变量，function-based，编译器依赖的一个作用对象，在**定义**的时候就已经确定内部自由变量的作用域，变量是通过对应的执行上下文环境中的变量对象实现的，一个作用域中可能存在多个执行上下文（闭包）

[JS 的 9 种作用域，你能说出几种？ - 掘金 (juejin.cn)](https://juejin.cn/post/7175125949053632549)

- 全局作用域：脚本模式下运行所有代码的默认作用域（可通过 window 访问）
- 模块作用域：模块模式中运行代码的作用域（实际上就是函数作用域）
- 函数作用域：由函数创建的作用域
- 块级作用域：一对花括号（代码块）创建，只对 let 和 var 声明有效

其他：

- Script 作用域：保存 let、const 声明的全局变量，不能通过window 访问
- Catch 作用域：可以访问错误对象
- with 作用域：会把传入的对象的值放到单独的作用域里，with 语句可以直接访问
- Closure 闭包作用域：函数返回函数时，会把用到的外部变量保存在 Closure作用域里（eval 闭包会保存外部所有作用域）
- Eval 作用域：保存 eval 代码声明的变量

当前作用域只能访问父级作用域中的变量，依次向上级作用域查询，直到访问到 全局对象终止，这种层级关系就是作用域链。

作用：保证对执行环境有权访问的所有变量和函数的**有序访问**。

### 闭包

> **闭包**（closure）是一个函数以及其捆绑的周边环境状态（**词法环境**）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，**闭包会随着函数的创建而被同时创建**。

```javascript
function init() {
  var name = "Mozilla"; // name 是一个被 init 创建的局部变量
  function displayName() { // displayName() 是内部函数，一个闭包
      alert(name); // 使用了父函数中声明的变量
  }
  displayName();
}
init();
```

用途：

- 在函数外部访问到函数内部的变量。可以使用这种方法模拟私有变量和方法
- 使已经运行结束的函数上下文中的变量对象继续留在内存中，避免被回收

### JavaScript 执行过程

[JavaScript 执行过程](https://www.cnblogs.com/MomentYY/p/15785719.html#:~:text=JavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%201%201.%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%202%202.%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88%EF%BC%88%E8%B0%83%E7%94%A8%E6%A0%88%EF%BC%89%203,3.%E8%B0%83%E7%94%A8%E6%A0%88%E8%B0%83%E7%94%A8GEC%E7%9A%84%E8%BF%87%E7%A8%8B%204%204.%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%205%205.%E5%8F%98%E9%87%8F%E7%8E%AF%E5%A2%83%E5%92%8C%E8%AE%B0%E5%BD%95%206%206.%E5%85%A8%E5%B1%80%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97%EF%BC%89)

### 垃圾回收

[Javascript的垃圾回收机制](https://juejin.cn/post/7038593947995734030)



### Map 和 WeakMap 

#### Map

键值对的集合（实际上是一个数组），它的键可以时任意类型，更完善的 Hash 结构。如果键是一个原始数据类型，只要两个键严格相同，就视为同一个键。

操作方法：

- `size`：成员总数。
- `set(key, value)`：设置键名 key 对应的键值 value，如果存在则覆盖，返回当前 Map 对象。
- `get(key)`
- `has(key)`
- `delete(key)`：删除某个键，成功则返回 true，失败则返回 false
- `clear()`：清除所有成员，无返回值

遍历方法：

- `keys()`：返回键名的迭代器
- `values()`：返回键值的迭代器
- `entries()`：返回所有成员的迭代器
- `forEach()`：遍历 Map 的所有成员	

#### 和 Object 的区别

|          | Map                                                          | Object                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 意外的键 | Map默认情况不包含任何键，只包含显式插入的键。                | Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。 |
| 键的类型 | Map的键可以是**任意值**，包括函数、对象或任意基本类型。      | Object 的键必须是**String 或是Symbol**。                     |
| 键的顺序 | Map 中的 key 是**有序**的。因此，当迭代的时候， Map 对象**以插入的顺序**返回键值。 | Object 的键是**无序**的                                      |
| Size     | Map 的键值对个数可以轻易地通过size 属性获取                  | Object 的键值对个数只能手动计算                              |
| 迭代     | Map 是 iterable 的，所以可以直接被迭代。                     | 迭代Object需要以某种方式获取它的键然后才能迭代。             |
| 性能     | 在频繁增删键值对的场景下表现更好。                           | 在频繁添加和删除键值对的场景下未作出优化。                   |

#### WeakMap

键是**弱引用，必须是对象**（null 除外），值可以任意，无 `clear()` 方法。

垃圾回收机制不将该引用考虑在内，只要键上引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存，不需要手动删除。

### Array



### Object

#### defineProperty

`defineProperty(obj, props, descriptor)`

descriptor:

|             |                                                              | 默认      |
| ----------- | ------------------------------------------------------------ | --------- |
| configuable | 该属性描述符类型（除 value 和 writable）可以被改变且该属性能被删除 | fasle     |
| enumerable  | 该属性可枚举                                                 | fasle     |
| writable    | value 能被赋值运算符改变                                     | false     |
| value       | 该属性对应的值                                               | undefined |
| get         | 属性的 getter 函数                                           | undefined |
| set         | 属性的 setter 函数                                           | undefined |

数据描述符：configurable、enumerable、value、witable

存取描述符：configurable、enumerable、get、set

#### create

`create(proto)` `create(proto, propertiesObject)`

proto：原型对象

propertiesObject（可选）：为新创建的对象添加指定的属性值和对应的属性描述符



### this

执行上下文中的一个属性，指向**最后一次调用这个方法的对象**。

取决于函数如何以及在哪里被调用。

四种调用模式判断（优先级高到低）：

1. 构造器调用：指向新创建的对象
2. apply、call、bind 调用：指向被绑定的对象
3. 方法调用：作为一个对象的方法，指向这个对象
4. 函数调用：指向全局

### 箭头函数与普通函数



### for in 和 for of

#### for of

> 在**可迭代对象**上（Array、Map、Set、String 等）上创建一个迭代循环，调用自定义迭代钩子，并为每个**属性的值**执行语句。

#### for in

> 以任意顺序迭代一个对象的**除 Symbol 以外**的**可枚举属性**，**包括继承的可枚举属性**

### 遍历器

作用：

1. 为各种数据结构提供一个统一的、简便的访问接口
2. 使得数据结构的成员能够按某种次序排列
3. 供 `for..of` 消费

遍历过程：

1. 创建一个指针对象，指向当前数据结构的起始位置。（遍历器对象本质就是一个指针对象）
2. 第一次调用指针对象的 `next` 方法，可以将指针指向数据结构的第一个成员
3. 第二次调用 `next` 方法就指向数据结构的第二个成员
4. 不断调用 `next` 方法知道它指向数据结构的结束位置

```typescript
interface Iterable {
  [Symbol.iterator](): Iterator
}
interface Iterator {
  next(value?: any): IterationResult
}
interface IterationResult {
  value : any,
  done: boolean
}
```



### 异步编程

#### 回调函数

>  作为参数传给另一个函数的函数

```javascript
ajax({
  url:"",
  success:function(data1){
      console.log(data1);
      ajax({
          url:"",
          success:function(data2){
              console.log(data2);
              ajax({
                
              })
          }
      })
  }
})
```

多个回调函数嵌套会造成回调地狱，代码耦合度太高，不利于代码维护。

#### Promise

异步编程的一种解决方案，将回调函数作为链式调用。语法上讲，是一个对象，可以获取异步操作的信息

特点：

- 对象状态不受外界影响（pending、fulfilled、rejected）
- 一旦状态改变就不会再变

缺点：

- 造成多个 then 的链式调用，造成代码语义不够明确

- 无法中途取消
- 如果不设置回调函数，Promise 内部抛出的错误不会反应到外部
- 当处于 pending 状态时，无法得知目前进展

原型对象上的方法：

- `then()`
- `catch()`
- `finally()`

静态方法：

- `all()`：确定所有异步操作**成功**

  - 全部状态变为 fulfilled，包装实例状态才会变成 fulfilled，传递返回值数组
  - 只要其中一个 rejected，包装实例状态变为 rejected，传递第一个被 rejected 实例的返回值

- `race()`：跟随**率先**改变的实例状态，并传递它的返回值

- `allSettled()`：确定所有异步操作**结束**，包装实例状态只可能变为 fulfilled

  ```javascript
  const resolved = Promise.resolve(42);
  const rejected = Promise.reject(-1);
  
  const allSettledPromise = Promise.allSettled([resolved, rejected]);
  
  allSettledPromise.then(function (results) {
    console.log(results);
  });
  // [
  //    { status: 'fulfilled', value: 42 },
  //    { status: 'rejected', reason: -1 }
  // ]
  ```

- `any()`：任意一个实例变成 fulfilled，包装实例变为 fulfilled

  - 所有参数实例都变成 rejected，包装实例变成 rejected

- `resolve()`

- `reject()`

#### Generator 函数

理解：

- 一个状态机，封装了多个内部状态。

- 一个返回遍历器对象（内部状态的指针对象）的函数。

- 普通函数，有两大特征：function 关键字和函数名之间有一个星号；使用 yield 表达式定义不同的内部状态。

#### async / await

Generator 语法糖，优化 then 链。

- 优化 Promise 的 then 链

- 代码读起来更加同步，非常优雅，不需要传递中间值
- 错误处理友好，可以使用 try / catch
- 调试友好（调试器只能跟踪同步代码的每一步）





### AJAX、Fetch、Axios

#### AJAX

> 其本身不是一种新技术，而是一个在 2005 年提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括：HTML 或 XHTML, CSS, JavaScript, DOM, XML (en-US), XSLT, 以及最重要的 **XMLHttpRequest**

通过在后台与服务器进行少量数据交换，可以使网页实现异步更新，在无需重新加载整个网页的情况下，能够更新部分网页。

缺点：

- 本身使针对 MVC 编程，不符合前端 MVVM 的浪潮
- 基于原生 XHR 开发，XHR 本身的架构不清晰
- 不符合关注分离的原则
- 配置和调用方式非常混乱，而且基于事件的异步模型不友好

#### Fetch

新的原生 JS API，AJAX 的替代品，基于 ES6 的 promise 对象设计，能更好地发送异步请求和处理响应。

优点：

- 语法简介，更语义化
- 基于标准 Promise 实现
- 更加底层，API 丰富
- 脱离了 XHR，使 ES 规范里新的实现

缺点：

- 只对网络请求报错，对 400、500都当作成功的请求
- 默认不会带 cookie
- 不支持 abort，不支持超时控制，造成流量浪费
- 没办法原生检测请求的进度，而 XHR 可以

#### Axios

基于 Promise 封装的网络请求库，基于 XHR 进行二次封装。

特点：

- 从浏览器中创建 XHR
- 从 node.js 客户端创建 http 请求
- 支持 Promise API
- 拦截请求和响应
- 转换请求数据和响应数据
- 取消请求
- 自动转换 JSON 数据
- 客户端支持防御 XSRF

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22da43184f0d4d4c84c8e12747fbcdff~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)



## vue



## 前端工程化



### webpack



### vite



## 网络

### DNS 和 CDN

[抓包理解 DNS 流程和 CDN 原理 - 掘金 (juejin.cn)](https://juejin.cn/post/7166995181093257246)

#### DNS

Domain Name System 网络协议

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dba74fdd2f74a12afb4928d2008b5e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

域名服务器之所以这样分级是为了通过负载均衡来分散压力，具体的域名解析都是由各自的权威域名服务器来处理的，根域名和顶级域名服务器只是做了个转发。

#### CDN

Content Delivery Network 基于 DNS 协议实现的一种**分布式网络**

做了更多及的负载均衡

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8d64623b55a4bc1bf731c53f2f0b5d8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)



# TS





