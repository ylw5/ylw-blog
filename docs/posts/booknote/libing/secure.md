# 同源策略

隔离各个站点之间的 DOM 交互、页面数据和网络通信

如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。

1. DOM 层面

   限制不同源的 JS 脚本对当前 DOM 对象读和写的操作。

2. 数据层面

   cookie、indexDB、LocalStorage等

3. 网络层面

   限制 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。

权衡安全和便利：

- 页面中可以嵌入第三方资源

  防止XSS攻击，引入了内容安全策略 CSP（类似白名单），让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JS 代码。

- 跨域资源共享CORS和跨文档消息机制（postMessgae）

# XSS

- 存储型
  1. 将恶意脚本提交到网站数据库中（比如名字填内联脚本）
  2. 然后用户向网站请求了包含恶意脚本的页面
  3. 恶意脚本将用户的数据传到自己服务器

- 反射型

  常用于恶意链接

  1. 恶意脚本作为发送给网络请求的一部分
  2. 网站将恶意脚本返回

- 基于 DOM

  Web 资源传输过程中或用户使用页面过程中修改 Web 页面数据。（比如网路劫持）

阻止：

- 服务器对输入脚本进行过滤和转码

- 充分利用 CSP

  - 限制加载其他域下的资源文件

  - 禁止向第三方域提交数据
  - 禁止执行内联脚本和未授权脚本
  - 等。。。。

- 使用 HttpOnly 属性保护 Cookie

# CSRF

跨站请求伪造。利用登录态（Cookie），通过第三方站点发送请求。

- 自动发起Get请求

  img src

- 自动发起Post请求

  表单

- 引诱用户点击链接（色图）

和XSS不同：不需要向用户的页面注入恶意代码，仅仅利用服务器的漏洞和用户的登录态。

防止：

- Cookie 的 SameSite 属性
  - Strict：完全禁止第三方 Cookie
  - Lax：第三方仅有链接和Get表单才会携带Cookie。Post和img、iframe等都不行
  - None

- 服务端验证请求的来源站点

  Http 请求头中的字段

  - Referrer：详细URL路径，可用 Referrer Policy 限制
  - Origin：只包含域名

  服务器优先判断 Origin 再看 Referrer

- CSRF Token

  服务器生成字符串植入返回的页面中用于验证

# HTTPS

