# instanceof

判断在其原型链中能否找到该类型的原型。

```javascript
function myInstance(obj, type) {
  // 获取对象的原型
  let proto = Object.getPrototypeOf(obj);
  // 获取该类型的原型
  const prototype = type.prototype;
  // 判断类型的的原型是否在该类型的原型链上
  while (true) {
    if (!proto) return false
    if (proto === prototype) return true
    proto = Object.getPrototypeOf(proto)
  }
}
```

# 深拷贝

# new 操作符

```javascript
function mynew(constructor, ...args) {
  // 检验构造函数类型
  if (typeof constructor !== 'function') {
    console.log('type error')
    return
  }
  // 1. 创建新对象，2. 以构造函数的原型作为原型对象
  const newObj = Object.create(constructor.prototype)
  // 3. 将构造函数的 this 绑定到创建的对象上 4. 执行
  const result = constructor.apply(newObj, args)
  // 判断构造函数返回值类型（函数或对象）
  let flag = result && (typeof result === 'object') || (typeof result === 'function')
  return flag ? result : newObj
}
```

# async / await

编写函数让 generator 函数自动执行，并返回一个 Promise

```javascript
function spawn(genFn) {
  return new Promise((resolve, reject) => {
    // 获取 generator 函数遍历器
    const gen = genFn()
    // step 函数用来跨过 yield （放行）
    // 传入遍历器操作
    function step(nextFn) {
      let nextStatus
      try {
        // 调用遍历器操作获取当前内部状态
        nextStatus = nextFn()
      } catch (error) {
        // 捕获错误直接 reject
        return reject(error)
      }
      const { value, done } = nextStatus
      // 如果结束则直接 resolve 
      if (done) {
        return resolve(value)
      }
      // 下一个内部状态
      // Promise.resolve 是防止 yield 表达式后是一个 promise
      Promise.resolve(value).then(
        // 将结果注入
        (v) => step(() => gen.next(v)),
        // 抛出错误
        (e) => step(() => gen.throw(e))
      )
    }
    // 开始执行
    step(() => gen.next())
  })
}
```

# 发布订阅

定义一个事件中心（中介），on函数订阅事件，注册回调，emit 函数发布事件，执行存储的对应回调。完全解耦。

```javascript
class EventEmitter {
  // 存放注册的事件和回调
  _events = {}

  // 事件订阅
  on(eventName, callback) {
    if (!this._events[eventName]) this._events[eventName] = []
    this._events[eventName].push(callback)
  }
  // 单次订阅
  once(eventName, callback) {
    // 包装回调函数
    const oneCallback = (...args) => {
      callback(...args)
      this.off(eventName, callback)
    }
    // 通过自定义属性找到对应的事件用来回调删除
    oneCallback.initialCallback = callback
    this.on(eventName, oneCallback)
  }
  // 取消订阅
  off(eventName, callback) {
    const callbacks = this._events[eventName] || []
    this._events[eventName] = callbacks.filter((cb) =>
      cb !== callback && cb.initialCallback !== callback
    )
  }
  // 事件发布
  emit(eventName, ...args) {
    const callbacks = this._events[eventName] || []
    callbacks.forEach((cb) => cb(...args))
  }
}
```

# 观察者模式

面向接口编程，被观察者（Subject）维护一套观察者（Observer）的集合，观察者实现统一的接口，被观察者调用该接口通知所有观察者。低耦合。

```javascript
// 被观察者
class Subject {
  constructor(name) {
    this.name = name
    this.observers = new Set() // 维护所有观察者的集合
    this.state = 'happy'
  }
  // 绑定观察者
  attach(observer) {
    this.observers.add(observer)
  }
  // 改变被观察者的状态
  setState(newState) {
    this.state = newState
    // 调用统一接口通知所有观察者
    this.observers.forEach(o => o.update(newState))
  }
}
// 观察者
class Observer {
  constructor(name) {
    this.name = name
  }
  // 统一接口
  update(newState) {
    console.log(this.name + ' get update ' + newState)
  }
}
```

# 防抖

```javascript
function debounce(fn, delay) {
  let timer = null;
  return function () {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      // 防止this指向错误
      fn.apply(this, arguments);
    }, delay);
  };
}
```

# 节流

```javascript
// 立即执行（在规定时间开始时执行）
function throttle1(fn, delay) {
  let preTime = 0
  return function () {
    let context = this
    let now = new Date()
    if (now - preTime > delay) {
      fn.apply(context, arguments)
      preTime = now
    }
  };
}

// 最后执行（在规定时间结束时执行）
function throttle2(fn, delay) {
  let timer = null
  return function () {
    if(!timer) {
      timer = setTimeout(() => {
        fn.apply(this, arguments)
        timer = null
      }, delay);
    }
  };
}
```

# call bind apply

```javascript
Function.prototype.myCall = function (thisArg, ...args) {
  thisArg = thisArg || window // 没有参数,null或undefined则赋予全局作用域
  const fn = Symbol()
  thisArg[fn] = this // 这里的this指向调用myCall的函数
  // 三元表达式针对无效thisArg
  const res = thisArg[fn] ? thisArg[fn](...args) : this(...args)
  delete thisArg[fn]
  return res
}
```

```javascript
Function.prototype.myApply = function (thisArg, argsArray) {
  thisArg = thisArg || window // 没有参数,null或undefined则赋予全局作用域
  argsArray = Array.from(argsArray) // 将类数组转换为数组
  const fn = Symbol()
  thisArg[fn] = this // 这里的this指向调用myapply的函数
  // 三元表达式针对无效thisArg
  const res = thisArg[fn] ? thisArg[fn](...argsArray) : this(...argsArray)
  delete thisArg[fn]
  return res
}

```

```javascript
Function.prototype.myBind = function (thisArg, ...innerArgs) {
  thisArg = thisArg || window
  const fn = Symbol()
  thisArg[fn] = this
  return function (...outerArgs) {
    // 三元表达式针对无效thisArg
    thisArg[fn] ? thisArg[fn](...innerArgs,...outerArgs) : this(...innerArgs,...outerArgs)
  }
}
```

# AJAX







